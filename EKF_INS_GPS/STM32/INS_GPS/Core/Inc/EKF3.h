/*
 * EKF.h
 *
 *  Created on: Feb 10, 2020
 *      Author: tung
 */

#ifndef INC_EKF_H_
#define INC_EKF_H_

#include "arm_math.h"
#include <math.h>
#include "mpu_data_type.hpp"
class EKF3 {
public:
//    Matrix x,y,A,B,P,Q,K,S,R,w;
	float32_t x0,x1,x2,x3,x4,x5,x6;
	float P[7][7];
	float K[7][6];

	float SPP[12];
	float SK[8];
	float Ha_b[2];
	float H_a[3][7];
	float Hm_b[1];
	float H_m[3][7];
	float ino[7];
	float KH[7][7];
	float Gx = 0, Gy = 0, Gz = 1;
	float w_[3];
	float y_[6];
	float Rax = 0.0001, Ray = 0.0001, Raz = 0.0001;
	float Rmx = 0.0001, Rmy = 0.001, Rmz = 0.001;
public:
	void loadEKF(){
          x0 = 1;
          x1 = x2 = x3 = 0;

		  for(uint8_t i = 0; i<7;i++){
			  for(uint8_t j = 0; j<7;j++){
				  if(i != j){
			         P[i][j]= 0;
				  }
				  else{
					  P[i][j]= 1;
				  }
			  }
		  }

	}
	EKF3();
	void updateEKF(IMU_data data_imu, MAG_data mag, float dt){
          float recipNorm;
          if(!isnan(data_imu.Acc_x) &&!isnan(data_imu.Acc_y)&&!isnan(data_imu.Acc_z)&&!isnan(data_imu.Gyro_x)&&!isnan(data_imu.Gyro_y)&&!isnan(data_imu.Gyro_z)){
        	      w_[0] = Gyro_x*DEC2RAD;
        	 	  w_[1] = Gyro_y*DEC2RAD;
        	 	  w_[2] = Gyro_z*DEC2RAD;

        	 	  y_[0] = data_imu.Acc_x;
        	 	  y_[1] = data_imu.Acc_y;
        	 	  y_[2] = data_imu.Acc_z;

        	 	  y_[3] = mag.Mag_x;
        	 	  y_[4] = mag.Mag_y;
        	 	  y_[5] = mag.Mag_z;


                 // x = A*x + B*w
        	 	 x0 = x0 - (Gx*dt*x1)/2 - (Gy*dt*x2)/2 - (Gz*dt*x3)/2 + (dt*x1*x4)/2 + (t*x2*x5)/2 + (t*x3*x6)/2;
        	 	 x1 = x1 + (Gx*dt*x0)/2 - (Gy*dt*x3)/2 + (Gz*dt*x2)/2 - (dt*x0*x4)/2 - (t*x2*x6)/2 + (t*x3*x5)/2;
        	 	 x2 = x2 + (Gx*dt*x3)/2 + (Gy*dt*x0)/2 - (Gz*dt*x1)/2 - (dt*x0*x5)/2 + (t*x1*x6)/2 - (t*x3*x4)/2;
        	 	 x3 = x3 - (Gx*dt*x2)/2 + (Gy*dt*x1)/2 + (Gz*dt*x0)/2 - (dt*x0*x6)/2 - (t*x1*x5)/2 + (t*x2*x4)/2;

        	 	 // P = A*P*A' + Q
        	 	 SPP[0] = P[3][6] + (P[4][6]*t*x3)/2 - (P[5][6]*t*x2)/2 - (P[6][6]*t*x1)/2;
        	 	 SPP[1] = P[3][5] + (P[4][5]*t*x3)/2 - (P[5][5]*t*x2)/2 - (P[6][5]*t*x1)/2;
        	 	 SPP[2] = P[3][4] + (P[4][4]*t*x3)/2 - (P[5][4]*t*x2)/2 - (P[6][4]*t*x1)/2;
        	 	 SPP[3] = P[2][6] - (P[4][6]*t*x4)/2 - (P[5][6]*t*x1)/2 + (P[6][6]*t*x2)/2;
        	 	 SPP[4] = P[2][5] - (P[4][5]*t*x4)/2 - (P[5][5]*t*x1)/2 + (P[6][5]*t*x2)/2;
        	 	 SPP[5] = P[2][4] - (P[4][4]*t*x4)/2 - (P[5][4]*t*x1)/2 + (P[6][4]*t*x2)/2;
        	 	 SPP[6] = P[1][6] - (P[4][6]*t*x1)/2 + (P[5][6]*t*x4)/2 - (P[6][6]*t*x3)/2;
        	 	 SPP[7] = P[1][5] - (P[4][5]*t*x1)/2 + (P[5][5]*t*x4)/2 - (P[6][5]*t*x3)/2;
        	 	 SPP[8] = P[1][4] - (P[4][4]*t*x1)/2 + (P[5][4]*t*x4)/2 - (P[6][4]*t*x3)/2;
        	 	 SPP[9] = P[0][6] + (P[4][6]*t*x2)/2 + (P[5][6]*t*x3)/2 + (P[6][6]*t*x4)/2;
        	 	 SPP[10] = P[0][5] + (P[4][5]*t*x2)/2 + (P[5][5]*t*x3)/2 + (P[6][5]*t*x4)/2;
        	 	 SPP[11] = P[0][4] + (P[4][4]*t*x2)/2 + (P[5][4]*t*x3)/2 + (P[6][4]*t*x4)/2;

        	 	 P[0][0] = P[0][0] + (P[4][0]*t*x2)/2 + (P[5][0]*t*x3)/2 + (P[6][0]*t*x4)/2 + (t*x2*SPP[11])/2 + (t*x3*SPP[10])/2 + (t*x4*SPP[9])/2;
        	 	 P[0][1] = P[0][1] + (P[4][1]*t*x2)/2 + (P[5][1]*t*x3)/2 + (P[6][1]*t*x4)/2 - (t*x1*SPP[11])/2 - (t*x3*SPP[9])/2 + (t*x4*SPP[10])/2;
        	 	 P[1][1] = P[1][1] - (P[4][1]*t*x1)/2 + (P[5][1]*t*x4)/2 - (P[6][1]*t*x3)/2 - (t*x1*SPP[8])/2 - (t*x3*SPP[6])/2 + (t*x4*SPP[7])/2;
        	 	 P[0][2] = P[0][2] + (P[4][2]*t*x2)/2 + (P[5][2]*t*x3)/2 + (P[6][2]*t*x4)/2 - (t*x1*SPP[10])/2 + (t*x2*SPP[9])/2 - (t*x4*SPP[11])/2;
        	 	 P[1][2] = P[1][2] - (P[4][2]*t*x1)/2 + (P[5][2]*t*x4)/2 - (P[6][2]*t*x3)/2 - (t*x1*SPP[7])/2 + (t*x2*SPP[6])/2 - (t*x4*SPP[8])/2;
        	 	 P[2][2] = P[2][2] - (P[4][2]*t*x4)/2 - (P[5][2]*t*x1)/2 + (P[6][2]*t*x2)/2 - (t*x1*SPP[4])/2 + (t*x2*SPP[3])/2 - (t*x4*SPP[5])/2;
        	 	 P[0][3] = P[0][3] + (P[4][3]*t*x2)/2 + (P[5][3]*t*x3)/2 + (P[6][3]*t*x4)/2 - (t*x1*SPP[9])/2 - (t*x2*SPP[10])/2 + (t*x3*SPP[11])/2;
        	 	 P[1][3] = P[1][3] - (P[4][3]*t*x1)/2 + (P[5][3]*t*x4)/2 - (P[6][3]*t*x3)/2 - (t*x1*SPP[6])/2 - (t*x2*SPP[7])/2 + (t*x3*SPP[8])/2;
        	 	 P[2][3] = P[2][3] - (P[4][3]*t*x4)/2 - (P[5][3]*t*x1)/2 + (P[6][3]*t*x2)/2 - (t*x1*SPP[3])/2 - (t*x2*SPP[4])/2 + (t*x3*SPP[5])/2;
        	 	 P[3][3] = P[3][3] + (P[4][3]*t*x3)/2 - (P[5][3]*t*x2)/2 - (P[6][3]*t*x1)/2 - (t*x1*SPP[0])/2 - (t*x2*SPP[1])/2 + (t*x3*SPP[2])/2;
        	 	 P[0][4] = SPP[11];
        	 	 P[1][4] = SPP[8];
        	 	 P[2][4] = SPP[5];
        	 	 P[3][4] = SPP[2];
        	 	 P[4][4] = P[4][4] + 0.001;
        	 	 P[0][5] = SPP[10];
        	 	 P[1][5] = SPP[7];
        	 	 P[2][5] = SPP[4];
        	 	 P[3][5] = SPP[1];
        	 	 P[4][5] = P[4][5];
        	 	 P[5][5] = P[5][5] + 0.001; // Q
        	 	 P[0][6] = SPP[9];
        	 	 P[1][6] = SPP[6];
        	 	 P[2][6] = SPP[3];
        	 	 P[3][6] = SPP[0];
        	 	 P[4][6] = P[4][6];
        	 	 P[5][6] = P[5][6];
        	 	 P[6][6] = P[6][6] + 0.001;


        	 	 // H

        	 	Ha_b[0] = 2*x4;
        	 	Ha_b[1] = 2*x3;

        	 	H_a[0][1] = Ha_b[1];
        	 	H_a[0][2] = Ha_b[0];
        	 	H_a[0][3] = 2*x1;
        	 	H_a[0][4] = 2*x2;
        	 	H_a[1][1] = -2*x2;
        	 	H_a[1][2] = -2*x1;
        	 	H_a[1][3] = Ha_b[0];
        	 	H_a[1][4] = Ha_b[1];
        	 	H_a[2][1] = 2*x1;
        	 	H_a[2][2] = -2*x2;
        	 	H_a[2][3] = -Ha_b[1];
        	 	H_a[2][4] = Ha_b[0];

        	 	Hm_b[0] = 2*x4;

        	 	H_a[0][1] = Hm_b[0];
        	 	H_a[0][2] = -2*x3;
        	 	H_a[0][3] = -2*x2;
        	 	H_a[0][4] = 2*x1;
        	 	H_a[1][1] = -2*x1;
        	 	H_a[1][2] = 2*x2;
        	 	H_a[1][3] = -2*x3;
        	 	H_a[1][4] = Hm_b[0];
        	 	H_a[2][1] = -2*x2;
        	 	H_a[2][2] = -2*x1;
        	 	H_a[2][3] = -Hm_b[0];
        	 	H_a[2][4] = -2*x3;
                // K = P*H'*(H*P*H' + R)^-1
        	 	SK[0] = 1/(Rmx - Hm_b[0]*(2*P[2][1]*x3 + 2*P[3][1]*x2 - 2*P[4][1]*x1 - P[1][1]*Hm_b[0]) + 2*x3*(2*P[2][2]*x3 + 2*P[3][2]*x2 - 2*P[4][2]*x1 - P[1][2]*Hm_b[0]) + 2*x2*(2*P[2][3]*x3 + 2*P[3][3]*x2 - 2*P[4][3]*x1 - P[1][3]*Hm_b[0]) - 2*x1*(2*P[2][4]*x3 + 2*P[3][4]*x2 - 2*P[4][4]*x1 - P[1][4]*Hm_b[0]));
        	 	SK[1] = 1/(Ray - Ha_b[0]*(2*P[1][3]*x2 + 2*P[2][3]*x1 - P[3][3]*Ha_b[0] - P[4][3]*Ha_b[1]) - Ha_b[1]*(2*P[1][4]*x2 + 2*P[2][4]*x1 - P[3][4]*Ha_b[0] - P[4][4]*Ha_b[1]) + 2*x2*(2*P[1][1]*x2 + 2*P[2][1]*x1 - P[3][1]*Ha_b[0] - P[4][1]*Ha_b[1]) + 2*x1*(2*P[1][2]*x2 + 2*P[2][2]*x1 - P[3][2]*Ha_b[0] - P[4][2]*Ha_b[1]));
        	 	SK[2] = 1/(Rmz + Hm_b[0]*(2*P[1][3]*x2 + 2*P[2][3]*x1 + 2*P[4][3]*x3 + P[3][3]*Hm_b[0]) + 2*x2*(2*P[1][1]*x2 + 2*P[2][1]*x1 + 2*P[4][1]*x3 + P[3][1]*Hm_b[0]) + 2*x1*(2*P[1][2]*x2 + 2*P[2][2]*x1 + 2*P[4][2]*x3 + P[3][2]*Hm_b[0]) + 2*x3*(2*P[1][4]*x2 + 2*P[2][4]*x1 + 2*P[4][4]*x3 + P[3][4]*Hm_b[0]));
        	 	SK[3] = 1/(Rax + Ha_b[1]*(2*P[3][1]*x1 + 2*P[4][1]*x2 + P[1][1]*Ha_b[1] + P[2][1]*Ha_b[0]) + Ha_b[0]*(2*P[3][2]*x1 + 2*P[4][2]*x2 + P[1][2]*Ha_b[1] + P[2][2]*Ha_b[0]) + 2*x1*(2*P[3][3]*x1 + 2*P[4][3]*x2 + P[1][3]*Ha_b[1] + P[2][3]*Ha_b[0]) + 2*x2*(2*P[3][4]*x1 + 2*P[4][4]*x2 + P[1][4]*Ha_b[1] + P[2][4]*Ha_b[0]));
        	 	SK[4] = 1/(Rmy - Hm_b[0]*(2*P[1][4]*x1 - 2*P[2][4]*x2 + 2*P[3][4]*x3 - P[4][4]*Hm_b[0]) + 2*x1*(2*P[1][1]*x1 - 2*P[2][1]*x2 + 2*P[3][1]*x3 - P[4][1]*Hm_b[0]) - 2*x2*(2*P[1][2]*x1 - 2*P[2][2]*x2 + 2*P[3][2]*x3 - P[4][2]*Hm_b[0]) + 2*x3*(2*P[1][3]*x1 - 2*P[2][3]*x2 + 2*P[3][3]*x3 - P[4][3]*Hm_b[0]));
        	 	SK[5] = 1/(Raz - Ha_b[1]*(2*P[1][3]*x1 - 2*P[2][3]*x2 - P[3][3]*Ha_b[1] + P[4][3]*Ha_b[0]) + Ha_b[0]*(2*P[1][4]*x1 - 2*P[2][4]*x2 - P[3][4]*Ha_b[1] + P[4][4]*Ha_b[0]) + 2*x1*(2*P[1][1]*x1 - 2*P[2][1]*x2 - P[3][1]*Ha_b[1] + P[4][1]*Ha_b[0]) - 2*x2*(2*P[1][2]*x1 - 2*P[2][2]*x2 - P[3][2]*Ha_b[1] + P[4][2]*Ha_b[0]));
        	 	SK[6] = Hm_b[0];
        	 	SK[7] = Ha_b[0];

        	 	K[0][0] = SK[3]*(P[0][2]*SK[7] + 2*P[0][3]*x1 + 2*P[0][4]*x2 + P[0][1]*Ha_b[1]);
        	 	K[0][1] = SK[1]*(P[0][3]*SK[7] - 2*P[0][1]*x2 - 2*P[0][2]*x1 + P[0][4]*Ha_b[1]);
        	 	K[0][2] = SK[5]*(P[0][4]*SK[7] + 2*P[0][1]*x1 - 2*P[0][2]*x2 - P[0][3]*Ha_b[1]);
        	 	K[0][3] = SK[0]*(P[0][1]*SK[6] - 2*P[0][2]*x3 - 2*P[0][3]*x2 + 2*P[0][4]*x1);
        	 	K[0][4] = SK[4]*(P[0][4]*SK[6] - 2*P[0][1]*x1 + 2*P[0][2]*x2 - 2*P[0][3]*x3);
        	 	K[0][5] = -SK[2]*(P[0][3]*SK[6] + 2*P[0][1]*x2 + 2*P[0][2]*x1 + 2*P[0][4]*x3);
        	 	K[1][0] = SK[3]*(P[1][2]*SK[7] + 2*P[1][3]*x1 + 2*P[1][4]*x2 + P[1][1]*Ha_b[1]);
        	 	K[1][1] = SK[1]*(P[1][3]*SK[7] - 2*P[1][1]*x2 - 2*P[1][2]*x1 + P[1][4]*Ha_b[1]);
        	 	K[1][2] = SK[5]*(P[1][4]*SK[7] + 2*P[1][1]*x1 - 2*P[1][2]*x2 - P[1][3]*Ha_b[1]);
        	 	K[1][3] = SK[0]*(P[1][1]*SK[6] - 2*P[1][2]*x3 - 2*P[1][3]*x2 + 2*P[1][4]*x1);
        	 	K[1][4] = SK[4]*(P[1][4]*SK[6] - 2*P[1][1]*x1 + 2*P[1][2]*x2 - 2*P[1][3]*x3);
        	 	K[1][5] = -SK[2]*(P[1][3]*SK[6] + 2*P[1][1]*x2 + 2*P[1][2]*x1 + 2*P[1][4]*x3);
        	 	K[2][0] = SK[3]*(P[2][2]*SK[7] + 2*P[2][3]*x1 + 2*P[2][4]*x2 + P[2][1]*Ha_b[1]);
        	 	K[2][1] = SK[1]*(P[2][3]*SK[7] - 2*P[2][1]*x2 - 2*P[2][2]*x1 + P[2][4]*Ha_b[1]);
        	 	K[2][2] = SK[5]*(P[2][4]*SK[7] + 2*P[2][1]*x1 - 2*P[2][2]*x2 - P[2][3]*Ha_b[1]);
        	 	K[2][3] = SK[0]*(P[2][1]*SK[6] - 2*P[2][2]*x3 - 2*P[2][3]*x2 + 2*P[2][4]*x1);
        	 	K[2][4] = SK[4]*(P[2][4]*SK[6] - 2*P[2][1]*x1 + 2*P[2][2]*x2 - 2*P[2][3]*x3);
        	 	K[2][5] = -SK[2]*(P[2][3]*SK[6] + 2*P[2][1]*x2 + 2*P[2][2]*x1 + 2*P[2][4]*x3);
        	 	K[3][0] = SK[3]*(P[3][2]*SK[7] + 2*P[3][3]*x1 + 2*P[3][4]*x2 + P[3][1]*Ha_b[1]);
        	 	K[3][1] = SK[1]*(P[3][3]*SK[7] - 2*P[3][1]*x2 - 2*P[3][2]*x1 + P[3][4]*Ha_b[1]);
        	 	K[3][2] = SK[5]*(P[3][4]*SK[7] + 2*P[3][1]*x1 - 2*P[3][2]*x2 - P[3][3]*Ha_b[1]);
        	 	K[3][3] = SK[0]*(P[3][1]*SK[6] - 2*P[3][2]*x3 - 2*P[3][3]*x2 + 2*P[3][4]*x1);
        	 	K[3][4] = SK[4]*(P[3][4]*SK[6] - 2*P[3][1]*x1 + 2*P[3][2]*x2 - 2*P[3][3]*x3);
        	 	K[3][5] = -SK[2]*(P[3][3]*SK[6] + 2*P[3][1]*x2 + 2*P[3][2]*x1 + 2*P[3][4]*x3);
        	 	K[4][0] = SK[3]*(P[4][2]*SK[7] + 2*P[4][3]*x1 + 2*P[4][4]*x2 + P[4][1]*Ha_b[1]);
        	 	K[4][1] = SK[1]*(P[4][3]*SK[7] - 2*P[4][1]*x2 - 2*P[4][2]*x1 + P[4][4]*Ha_b[1]);
        	 	K[4][2] = SK[5]*(P[4][4]*SK[7] + 2*P[4][1]*x1 - 2*P[4][2]*x2 - P[4][3]*Ha_b[1]);
        	 	K[4][3] = SK[0]*(P[4][1]*SK[6] - 2*P[4][2]*x3 - 2*P[4][3]*x2 + 2*P[4][4]*x1);
        	 	K[4][4] = SK[4]*(P[4][4]*SK[6] - 2*P[4][1]*x1 + 2*P[4][2]*x2 - 2*P[4][3]*x3);
        	 	K[4][5] = -SK[2]*(P[4][3]*SK[6] + 2*P[4][1]*x2 + 2*P[4][2]*x1 + 2*P[4][4]*x3);
        	 	K[5][0] = SK[3]*(P[5][2]*SK[7] + 2*P[5][3]*x1 + 2*P[5][4]*x2 + P[5][1]*Ha_b[1]);
        	 	K[5][1] = SK[1]*(P[5][3]*SK[7] - 2*P[5][1]*x2 - 2*P[5][2]*x1 + P[5][4]*Ha_b[1]);
        	 	K[5][2] = SK[5]*(P[5][4]*SK[7] + 2*P[5][1]*x1 - 2*P[5][2]*x2 - P[5][3]*Ha_b[1]);
        	 	K[5][3] = SK[0]*(P[5][1]*SK[6] - 2*P[5][2]*x3 - 2*P[5][3]*x2 + 2*P[5][4]*x1);
        	 	K[5][4] = SK[4]*(P[5][4]*SK[6] - 2*P[5][1]*x1 + 2*P[5][2]*x2 - 2*P[5][3]*x3);
        	 	K[5][5] = -SK[2]*(P[5][3]*SK[6] + 2*P[5][1]*x2 + 2*P[5][2]*x1 + 2*P[5][4]*x3);
        	 	K[6][0] = SK[3]*(P[6][2]*SK[7] + 2*P[6][3]*x1 + 2*P[6][4]*x2 + P[6][1]*Ha_b[1]);
        	 	K[6][1] = SK[1]*(P[6][3]*SK[7] - 2*P[6][1]*x2 - 2*P[6][2]*x1 + P[6][4]*Ha_b[1]);
        	 	K[6][2] = SK[5]*(P[6][4]*SK[7] + 2*P[6][1]*x1 - 2*P[6][2]*x2 - P[6][3]*Ha_b[1]);
        	 	K[6][3] = SK[0]*(P[6][1]*SK[6] - 2*P[6][2]*x3 - 2*P[6][3]*x2 + 2*P[6][4]*x1);
        	 	K[6][4] = SK[4]*(P[6][4]*SK[6] - 2*P[6][1]*x1 + 2*P[6][2]*x2 - 2*P[6][3]*x3);
        	 	K[6][5] = -SK[2]*(P[6][3]*SK[6] + 2*P[6][1]*x2 + 2*P[6][2]*x1 + 2*P[6][4]*x3);
               // Inovation (y - H*x)
        	   float x[4] = {x0,x1,x2,x3};
               for(uint8_t i = 0; i < 4; i++){
            	   ino[0] += H_a[0][i]*x[i];
            	   ino[1] += H_a[1][i]*x[i];
            	   ino[2] += H_a[2][i]*x[i];

            	   ino[3] += H_m[3][i]*x[i];
            	   ino[4] += H_m[4][i]*x[i];
            	   ino[5] += H_m[5][i]*x[i];

               }

               ino[0] = y_[0] - ino[0];
               ino[1] = y_[1] - ino[1];
               ino[2] = y_[2] - ino[2];

               ino[3] = y_[3] - ino[3];
               ino[4] = y_[4] - ino[4];
               ino[5] = y_[5] - ino[5];
               // Fusion x = x + K*ino, since K is separately calculated, we can calculate like this

               for(uint8_t j = 0; j < 6; j++){
            	   x0 += K[0][j]*ino[j];
            	   x1 += K[1][j]*ino[j];
            	   x2 += K[2][j]*ino[j];
            	   x3 += K[3][j]*ino[j];
            	   x4 += K[4][j]*ino[j];
            	   x5 += K[5][j]*ino[j];
            	   x6 += K[6][j]*ino[j];
                  }
              // update P = (I - K*H)*P
               for (int i = 0; i < 7; i++){
               	   for(int j = 0 ; j < 7; j++){
               	       for(int k = 0; k < 6 ; k++){
               	    	   if(k<3)
               	    	       KH[i][j] += K[i][k] * H_a[k][j];
               	    	   else
               	    		   KH[i][j] += K[i][k] * H_m[k][j];
               	       }

               	       if(i = j){   // I - KH
               	    	   KH[i][j] = 1 - KH[i][j];
               	       }
               	   }
               }

               for (int i = 0; i < 7; i++)
               	   for(int j = 0 ; j < 7; j++)
               	       for(int k = 0; k < 7; k++)
               	    	   P[i][j] += KH[i][k] * P[k][j];

               	       float temp = (float) (x0 * x0 + x1 * x1 + x2 * x3 + x3 * x3);
               	       temp = sqrt(temp);
               	       float recipNorm;
               	    	  recipNorm = 1/(temp);
               	    	  x0 *= recipNorm;
               	    	  x1 *= recipNorm;
               	    	  x2 *= recipNorm;
               	    	  x3 *= recipNorm;

               	    	  angle = getAngle1(x0,x1,x2,x3);
          }
	}
	EULER_angle getAngle1(float q0,float q1, float q2,float q3){
			float r,p,y;
			EULER_angle angle_e;


			float sinr = 2*(q0*q1 + q2 * q3);
			float cosr = 1 - 2*(q1*q1 + q2 * q2);
			r = atan2(sinr, cosr);


				float sinp = 2*( q0*q2 - q3*q1);
			    if (sinp >= 1)
			    	p = PI/2;
			    else{
			    	if(sinp <= -1){
			    	p = -PI/2;
			    }
			    else{
			    	p = asin(sinp);
			    }
			    }


				float siny = 2*( q0*q3 + q2*q1);
				float cosy = 1 - 2*( q1*q1 + q3*q3);
				y = atan2(siny, cosy);

				angle_e.roll = r*RAD2DEC;
				angle_e.pitch = p*RAD2DEC;
				angle_e.yaw = y*RAD2DEC;
				return angle_e;
		}

	EULER_angle angle;
	virtual ~EKF3();
};
EKF3::EKF3(){

}
EKF3::~EKF3() {
	// TODO Auto-generated destructor stub
	 // free(this->data);
}

#endif /* INC_EKF_H_ */
